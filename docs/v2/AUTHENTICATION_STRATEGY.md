# Authentication Strategy: Current Implementation & Pepper Enhancement

## Current Authentication Strategy

### Password Storage & Hashing

Our authentication system uses a **defense-in-depth** approach with multiple layers of security:

1. **BCrypt Hashing**: All passwords are hashed using BCrypt.Net-Next before storage
   - Passwords are **never stored in plain text**
   - Each password gets a **unique random salt** automatically generated by BCrypt
   - The salt is embedded in the hash string itself (format: `$2a$10$...`)
   - Work factor: Default (typically 10 rounds, meeting our minimum requirement)

2. **Per-Password Salting**: BCrypt automatically generates a unique salt for each password
   - Even if two users have identical passwords, their hashes will be different
   - The salt is stored with the hash (no separate database field needed)
   - This prevents rainbow table attacks and password comparison attacks

3. **JWT Token-Based Authentication**: After successful login, users receive a JWT token
   - Tokens include user ID, email, role, and organization ID
   - Tokens expire after 30 minutes (configurable)
   - Stateless authentication reduces server-side session storage needs

### Current Flow

**Registration**:
1. User provides email, password, first name, last name
2. System validates email uniqueness
3. Password is hashed with BCrypt: `BCrypt.HashPassword(password)`
4. Hashed password stored in `User.PasswordHash` field
5. JWT token generated and returned

**Login**:
1. User provides email and password
2. System retrieves user by email
3. Password verified: `BCrypt.Verify(password, storedHash)`
4. On success, JWT token generated and returned

### Security Strengths

✅ **Industry-standard hashing** - BCrypt is well-established and secure  
✅ **Automatic per-password salting** - No manual salt management needed  
✅ **No plain text storage** - Passwords never stored in readable format  
✅ **Secure password verification** - Constant-time comparison via BCrypt  
✅ **Stateless authentication** - JWT tokens reduce session management complexity

## The Gap: Database-Only Protection

While our current implementation is secure, it has one potential weakness:

**If the database is compromised**, an attacker who gains access to the password hashes can attempt to crack them using:
- Rainbow tables (mitigated by per-password salts)
- Brute force attacks (slowed by BCrypt's work factor)
- Dictionary attacks (slowed by BCrypt's work factor)

However, if an attacker has the database dump, they can work offline at their own pace, potentially cracking weak passwords given enough time and computational resources.

## Adding Pepper: Defense-in-Depth Enhancement

### What is Pepper?

**Pepper** is an application-level secret that is combined with passwords before hashing. Unlike salt (which is unique per password and stored with the hash), pepper is:
- A **single secret value** shared across all passwords
- Stored in **application configuration/environment variables** (not in the database)
- Added to the password before BCrypt hashing: `BCrypt.HashPassword(password + pepper)`

### Why Add Pepper?

1. **Additional Security Layer**: Even if the database is compromised, attackers still need the pepper secret to crack passwords
   - Database dump alone is insufficient
   - Attacker must compromise both database AND application configuration
   - Significantly increases the attack surface required

2. **Defense-in-Depth**: Complements existing BCrypt salting
   - Salt protects against rainbow tables and password comparison
   - Pepper protects against offline attacks when database is compromised
   - Together, they provide multiple layers of protection

3. **Low Implementation Cost**: Minimal code changes required
   - No database schema changes needed
   - No new dependencies required
   - Backward compatible with existing passwords (during transition)

4. **Industry Best Practice**: Many security-conscious applications use pepper
   - Recommended by security experts for sensitive applications
   - Provides additional protection with minimal overhead

### How Pepper Works

**Registration (with pepper)**:
```
User Password: "MyPassword123"
Pepper (from config): "secret-pepper-value-xyz"
Combined: "MyPassword123secret-pepper-value-xyz"
BCrypt Hash: "$2a$10$N9qo8uLOickgx2ZMRZoMye..."
```

**Login (with pepper)**:
```
User enters: "MyPassword123"
System adds pepper: "MyPassword123secret-pepper-value-xyz"
BCrypt verifies against stored hash: ✅ Match
```

**Attack Scenario (without pepper)**:
- Attacker gets database dump with hashes
- Can attempt to crack passwords offline
- With pepper: Even with database, cannot verify guesses without pepper secret

**Attack Scenario (with pepper)**:
- Attacker gets database dump with hashes
- Tries to crack password "MyPassword123"
- Without pepper, `BCrypt.Verify("MyPassword123", hash)` fails
- Attacker needs to guess both password AND pepper
- Significantly harder attack

### Implementation Plan

1. **Configuration**: Add `PasswordPepper` to application settings (environment variable in production)
2. **Registration**: Apply pepper before hashing: `BCrypt.HashPassword(password + pepper)`
3. **Login**: Apply pepper before verification: `BCrypt.Verify(password + pepper, hash)`
4. **Backward Compatibility**: Support both old (no pepper) and new (with pepper) formats during transition
5. **Security**: Never log or expose pepper value

### Trade-offs

**Benefits**:
- Additional security layer with minimal code changes
- No database migration required
- Backward compatible implementation possible

**Considerations**:
- Pepper must be securely stored (environment variables, secrets management)
- If pepper is lost, all passwords become invalid (backup required)
- Pepper rotation requires password reset for all users (advanced scenario)

## Conclusion

Our current authentication strategy using BCrypt with per-password salting is secure and follows industry best practices. Adding pepper provides an additional layer of defense-in-depth that protects against scenarios where the database is compromised but application configuration remains secure. This enhancement aligns with security best practices for applications handling sensitive user data.

---

**Status**: Planned for implementation  
**Priority**: Medium (security enhancement)  
**Impact**: Low code changes, high security value

